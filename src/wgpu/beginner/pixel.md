# 一闪一闪亮晶晶——像素与窗口

如有些读者已经察觉的，我们的渲染过程中充斥着各种各样的坐标系。在这一个大章节的后面，我们会花更多章节解释各种坐标系和之间的关系。然而，我们目前为止只涉及了二维的渲染，从而涉及的坐标系大幅减少。在这个章节，我想向读者介绍我们目前主要接触到的几个坐标系。

## 在图形学，我能看到各种各样的坐标

> **易！悟！**
> <p align="right">——理塘王子</p>

### 窗口坐标

我们渲染的结果最终都是呈现到窗口上的。由于窗口的平移之类是系统负责，我们可以不关注屏幕上的绝对坐标，但是我们自然要有办法描述我们渲染的结果在窗口上的相对位置。国际惯例是将窗口的左上角像素取为$\left(0,0\right)$，横向右一个像素为$\hat{x}$坐标单位，纵向下一个像素为$\hat{y}$坐标单位，WGPU中也并不例外。我们的帧缓冲便对应到这个坐标上。

### 视口 _Viewport_

有些情况下，我们希望能在一个窗口上输出不止一个结果。比如左半边渲染一个玩家的视野，右半边渲染另一个玩家的视野之类。尽管这种操作有很多实现方案，视口是其中最直接的一种。视口相当于在窗口中框选出一个区域当作一整个窗口渲染。因此，大部分时候，我们指的“窗口坐标”原则上应当理解成视口坐标（然而也有情况不是）。在我们的教程中，我们的视口永远都是选择整个窗口，所以窗口坐标和视口坐标是一致的。在WGPU中，我们可以通过[`wgpu::RenderPass::set_viewport`](https://docs.rs/wgpu/latest/wgpu/struct.RenderPass.html#method.set_viewport)方法来设置视口。前四个参数分别是左上角的位置的x和y窗口坐标，视口的长和宽。后两个参数在3D渲染时才有意义，我们平常将其设置为各自默认值`0.0`和`1.0`即可。不过我们正常不会说“视口坐标”，因为视口内部的坐标从来不出现在我们的计算当中。

### 归一设备坐标 _Normalized Device Coordinates_

归一设备坐标（NDC）是一个三维坐标系$\left[-1,1\right]\times\left[-1,1\right]\times\left[0,1\right]$。其Z轴仅在3D渲染时有意义，故我们暂时忽略Z轴。NDC的坐标会被线性映射到视口坐标中。换句话说，$\left(-1,1\right)$会对应到视口的左上角，而相应的$\left(1,-1\right)$会对应到视口的右下角。我们在上一节的顶点的坐标事实上就是NDC里面的坐标。然而请注意，顶点着色器输出的坐标通常 **不是** NDC，我们将会在3D渲染中更详细地讨论这一事实。

## 顶点着色器和他的坐标朋友们

虽然在二维渲染中我们并不需要处理太多坐标系相关的内容，但是我们已经有了展示顶点着色器作用的绝佳例子了！在通常的二维渲染中，我们需要以像素为单位描述位置，然而这在NDC中是不好做到的。抛开其他的不谈，如果我们采用一个固定的坐标，就会导致我们的图形随着窗口缩放而拉伸。如果我们想要一个固定的大小，就需要我们反复地计算像素宽度对应的NDC宽度。想象一下如果我们有成千上万个（其实通常可以比这更多）图形需要渲染，那我们就需要每一帧计算成千上万的坐标然后将其重新上传至GPU，低效不堪。然而稍微一想，我们就会发现端倪：渲染过程的最后无非是GPU统一把NDC坐标线性变换到视口（在我们的情况下是窗口）中，那我们先让GPU统一进行其逆变换不就可以了吗？顶点着色器就担任了这个对一些顶点统一进行变换的作用。听上去要算的东西还是差不多的，为什么我们更喜欢这样做呢？一是因为这样可以大幅减少CPU和GPU之间相对比较慢的数据交换，因为我们的顶点数据和变换用的数据都可以存在GPU中；二是因为GPU的硬件是对矩阵乘法特化的（不知道为什么和矩阵乘法扯上关系？下一个大章节你就知道了）。这个说法有个地方听上去有些弱智：既然我们本来就想直接输出到窗口坐标，为什么还要有一个NDC呢？在二维渲染的语境下，我没有想到什么为其开脱的理由。但是在三维渲染中，我们将会轻易注意到其重要地位。

我们还是先实现再说吧！先考虑我们需要什么样一个矩阵进行变换。假设我们窗口的宽度是$w$，高度是$h$（像素），而一个像素的坐标是$\left(x_p, y_p\right)$。这个像素最终应该到达的NDC中的位置记为$\left(x_{NDC},y_{NDC}\right)$，则有：

$$
\begin{cases}
x_{NDC}=\frac{2x_p-w}{w}=\frac{2x_p}{w}-1 \\
y_{NDC}=\frac{2y_p-h}{h}=\frac{2y_p}{h}-1
\end{cases}
$$

是一个缩放加上平移。但平移并不是一个线性变换，这怎么办呢？

> 下面是给有线代基础同学的数学内容，不感兴趣可以选择[跳过](#下课)

### 理塘DJ的完美数学教室

在数学中，线性变换配上平移组成的变换被称为 **仿射变换(_Affine Transformation_)**，而仿射变换也是可以用矩阵表示的！一般地说，如果我们想表示一个$\mathbb{R}^n$上的平移$\mathbf{x}\mapsto \mathbf{x}+\mathbf{p}$，那么我们使用一个$n+1$维向量表示$\mathbf{x}$

$$
\mathbf{x}=\begin{bmatrix}x_1\\x_2\\\vdots\\x_n\\1\end{bmatrix}
$$

并用如下矩阵作用于其上

$$
T=\begin{bmatrix}
    1 & 0 & \cdots & 0 & p_1 \\
    0 & 1 & \cdots & 0 & p_2 \\
    \vdots & \vdots & \ddots & \vdots & \vdots \\
    0 & 0 & \cdots & 1 & p_n \\
    0 & 0 & \cdots & 0 & 1
\end{bmatrix}
$$

不难验证

$$
T\mathbf{x}=\begin{bmatrix}x_1+p_1\\x_2+p_2\\\vdots\\x_n+p_n\\1\end{bmatrix}
$$

成功进行了平移。形如$T$的矩阵被称为平移矩阵，我们完全可以把它当作一般的线性变换处理。更一般地说，具有如下形状的分块矩阵：

$$
M=\begin{bmatrix}
    A_{n\times n} & \mathbf{p}_{n\times 1} \\
    0_{1\times n} & 1
\end{bmatrix}
$$

作用于向量

$$
\mathbf{x}_{affine}=\begin{bmatrix}\mathbf{x}_{n\times 1}\\1\end{bmatrix}_{\left(n+1\right)\times 1}
$$

有效果（由分块矩阵乘法易证）

$$\mathbf{x}_{affine} \mapsto \left(A\mathbf{x}+\mathbf{p}\right)_{affine}$$

因此由于在我们的情况下，$A$为矩阵$\begin{bmatrix}\frac{2}{w} & 0\\0 & \frac{2}{h}\end{bmatrix}$，$\mathbf{p}$为向量$\begin{bmatrix}-1\\-1\end{bmatrix}$。因而我们想要的矩阵便是

$$
\begin{bmatrix}
    \frac{2}{w} & 0 & -1 \\
    0 & \frac{2}{h} & -1 \\
    0 & 0 & 1
\end{bmatrix}
$$

但是因为我们需要给三维处理留下一点空间，我们填上$\hat{z}$的单位映射得到

$$
\begin{bmatrix}
    \frac{2}{w} & 0 & 0 & -1 \\
    0 & \frac{2}{h} & 0 & -1 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}
$$

这便是我们最终需要使用的矩阵了！

### 下课

给跳过的同学贴上省流版本：我们只需要将这个矩阵

$$
\begin{bmatrix}
    \frac{2}{w} & 0 & 0 & -1 \\
    0 & \frac{2}{h} & 0 & -1 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}
$$

乘到

$$
\mathbf{x}=\begin{bmatrix}x_p\\y_p\\z\\1\end{bmatrix}
$$

上，就能在前两个分量中得到我们想要的结果。其中$z$的值随意，但是由于NDC的$\hat{z}$取值范围不能超过$\left[0,1\right]$，这里的$z$也不可以超过$\left[0,1\right]$。

为了方便在程序中操作矩阵，我们引入一个新的依赖

```toml
# Cargo.toml

[dependencies]
# ...
cgmath = "0.18"
```
